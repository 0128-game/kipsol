<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>独自言語メモ帳 v4</title>
    <style>
        body { font-family: sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { background: white; padding: 25px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 95%; max-width: 1000px; }
        textarea { width: 100%; height: 80px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 18px; margin-bottom: 20px; resize: vertical; outline: none; }
        textarea:focus { border-color: #007bff; }
        #canvas-container { width: 100%; overflow-x: auto; background: #fff; border: 1px solid #ccc; border-radius: 8px; }
        canvas { display: block; }
        .info { font-size: 0.85rem; color: #555; line-height: 1.6; background: #e9ecef; padding: 15px; border-radius: 8px; margin-top: 20px; }
    </style>
</head>
<body>

<div class="container">
    <h2>記号言語メモ帳 (1.5倍サイズ & 接続処理最適化)</h2>
    <textarea id="input" placeholder="入力例: koko, sisu, tate."></textarea>
    
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="info">
        <strong>【更新仕様】</strong><br>
        ・<strong>サイズ拡大</strong>：各記号を1.5倍の大きさで描画します。<br>
        ・<strong>動的接続</strong>：母音（i, u, o）の後は、次に子音や記号が来るまで線を描画しません。<br>
        ・<strong>接続ルール</strong>：母音を挟む場合は「直接接触」、子音が連続する場合は「直線」で描画します。
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('input');

    // 1.5倍に拡大したサイズ設定
    const SCALE = 1.5;
    const R_BIG = 18 * SCALE;
    const R_SMALL = 10 * SCALE;
    const R_DOT = 3 * SCALE;
    const BASE_LINE_DIST = 45 * SCALE;

    const CHAR_MAP = {
        'z': { r: R_BIG, lines: 0, type: 'big' },
        's': { r: R_SMALL, lines: 0, type: 'small' },
        'd': { r: R_BIG, lines: 3, type: 'big' },
        't': { r: R_SMALL, lines: 3, type: 'small' },
        'g': { r: R_BIG, lines: 4, type: 'big' },
        'k': { r: R_SMALL, lines: 4, type: 'small' },
        'b': { r: R_BIG, lines: 6, type: 'big' },
        'p': { r: R_SMALL, lines: 6, type: 'small' },
        'l': { r: R_BIG, lines: 0, type: 'double' },
        'n': { r: R_BIG, lines: 3, type: 'double' },
    };

    function drawSymbol(x, y, charCode) {
        const config = CHAR_MAP[charCode];
        if (!config) return;
        ctx.beginPath();
        ctx.lineWidth = 2.5; // 太さも少し調整
        ctx.strokeStyle = '#333';
        
        if (config.type === 'big' || config.type === 'double') {
            ctx.moveTo(x + R_BIG, y);
            ctx.arc(x, y, R_BIG, 0, Math.PI * 2);
        }
        if (config.type === 'small' || config.type === 'double') {
            ctx.moveTo(x + R_SMALL, y);
            ctx.arc(x, y, R_SMALL, 0, Math.PI * 2);
        }
        ctx.stroke();

        // 中心の点
        ctx.beginPath();
        ctx.arc(x, y, 2 * SCALE, 0, Math.PI * 2);
        ctx.fill();

        // 分割線
        if (config.lines > 0) {
            ctx.beginPath();
            for (let i = 0; i < config.lines; i++) {
                const angle = (Math.PI * 2 / config.lines) * i - Math.PI / 2;
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * R_SMALL, y + Math.sin(angle) * R_SMALL);
            }
            ctx.stroke();
        }
    }

    function render() {
        const text = input.value.toLowerCase().replace(/[^iuotkspdgzbl,\.]/g, '');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let curX = 60;
        let curY = 150;
        
        canvas.width = Math.max(900, text.length * 70 + 100);
        canvas.height = 400;

        for (let i = 0; i < text.length; i++) {
            let char = text[i];
            
            if (CHAR_MAP[char]) {
                drawSymbol(curX, curY, char);
                const currentR = CHAR_MAP[char].r;
                
                let next = text[i+1];
                if (!next) break;

                // 母音判定
                if ("iuo".includes(next)) {
                    let angle = 0;
                    if (next === 'i') angle = -Math.PI / 6;
                    if (next === 'u') angle = Math.PI / 6;

                    let afterVowel = text[i+2];
                    if (afterVowel) {
                        if (CHAR_MAP[afterVowel]) {
                            // 子音+母音+子音: 直接くっつく
                            let dist = currentR + CHAR_MAP[afterVowel].r;
                            curX += Math.cos(angle) * dist;
                            curY += Math.sin(angle) * dist;
                            i++; // 母音をスキップ
                        } else if (afterVowel === ',') {
                            // 子音+母音+語末記号: 直接くっつく
                            let dist = currentR + R_DOT;
                            curX += Math.cos(angle) * dist;
                            curY += Math.sin(angle) * dist;
                            
                            ctx.beginPath();
                            ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            curX += 40 * SCALE; // 次の語へ
                            curY = 150; // 高さリセット
                            i += 2; // 母音とカンマをスキップ
                        } else if (afterVowel === '.') {
                            // 子音+母音+文末（語末記号なしのピリオドはルール外想定だが一応処理）
                            curX += 40 * SCALE;
                            curY = 150;
                            i++;
                        }
                    } else {
                        // 次の文字がない場合、描画を保留（ループを抜ける）
                        break;
                    }
                } else if (CHAR_MAP[next]) {
                    // 子音+子音: 直線でつなぐ
                    let targetX = curX + BASE_LINE_DIST;
                    let targetY = curY;
                    ctx.beginPath();
                    ctx.moveTo(curX, curY);
                    ctx.lineTo(targetX, targetY);
                    ctx.stroke();
                    curX = targetX;
                    curY = targetY;
                } else if (next === ',') {
                    // 子音+語末（母音なし）: 直線
                    let targetX = curX + 25 * SCALE;
                    ctx.beginPath();
                    ctx.moveTo(curX, curY);
                    ctx.lineTo(targetX, curY);
                    ctx.stroke();
                    curX = targetX;
                }
            } else if (char === ',') {
                ctx.beginPath();
                ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                ctx.stroke();
                curX += 40 * SCALE;
                curY = 150;
            } else if (char === '.') {
                const h = R_SMALL;
                ctx.beginPath();
                ctx.moveTo(curX + 5, curY - h); ctx.lineTo(curX + 5, curY + h);
                ctx.moveTo(curX + 15, curY - h); ctx.lineTo(curX + 15, curY + h);
                ctx.stroke();
                curX += 50 * SCALE;
                curY = 150;
            }
        }
    }

    input.addEventListener('input', render);
    render();
</script>

</body>
</html>
