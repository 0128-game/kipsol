<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>独自言語メモ帳 v5</title>
    <style>
        body { font-family: sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { background: white; padding: 25px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 95%; max-width: 1000px; }
        textarea { width: 100%; height: 80px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 18px; margin-bottom: 20px; resize: vertical; outline: none; }
        textarea:focus { border-color: #007bff; }
        #canvas-container { width: 100%; overflow-x: auto; background: #fff; border: 1px solid #ccc; border-radius: 8px; }
        canvas { display: block; }
        .info { font-size: 0.85rem; color: #555; line-height: 1.6; background: #e9ecef; padding: 15px; border-radius: 8px; margin-top: 20px; }
    </style>
</head>
<body>

<div class="container">
    <h2>記号言語メモ帳 (分割線サイズ・角度調整版)</h2>
    <textarea id="input" placeholder="入力例: koko, sisu, tate."></textarea>
    
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="info">
        <strong>【現在の描画仕様】</strong><br>
        ・<strong>分割線</strong>：有声音（大円）は外円まで、無声音（小円）は内円までの長さに調整。<br>
        ・<strong>角度修正</strong>：k, g は 45° 回転、t, d は 30° 回転して描画。<br>
        ・<strong>接続</strong>：母音の後は、次の文字が入力されるまで線を描画せず待機します。
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('input');

    const SCALE = 1.5;
    const R_BIG = 18 * SCALE;
    const R_SMALL = 10 * SCALE;
    const R_DOT = 3 * SCALE;
    const BASE_LINE_DIST = 45 * SCALE;

    const CHAR_MAP = {
        'z': { r: R_BIG,   lines: 0, type: 'big'   , offset: 0 },
        's': { r: R_SMALL, lines: 0, type: 'small' , offset: 0 },
        'd': { r: R_BIG,   lines: 3, type: 'big'   , offset: Math.PI / 6 }, // 30度
        't': { r: R_SMALL, lines: 3, type: 'small' , offset: Math.PI / 6 }, // 30度
        'g': { r: R_BIG,   lines: 4, type: 'big'   , offset: Math.PI / 4 }, // 45度
        'k': { r: R_SMALL, lines: 4, type: 'small' , offset: Math.PI / 4 }, // 45度
        'b': { r: R_BIG,   lines: 6, type: 'big'   , offset: 0 },
        'p': { r: R_SMALL, lines: 6, type: 'small' , offset: 0 },
        'l': { r: R_BIG,   lines: 0, type: 'double', offset: 0 },
        'n': { r: R_BIG,   lines: 3, type: 'double', offset: Math.PI / 6 },
    };

    function drawSymbol(x, y, charCode) {
        const config = CHAR_MAP[charCode];
        if (!config) return;
        ctx.beginPath();
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#333';
        
        if (config.type === 'big' || config.type === 'double') {
            ctx.moveTo(x + R_BIG, y);
            ctx.arc(x, y, R_BIG, 0, Math.PI * 2);
        }
        if (config.type === 'small' || config.type === 'double') {
            ctx.moveTo(x + R_SMALL, y);
            ctx.arc(x, y, R_SMALL, 0, Math.PI * 2);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y, 2 * SCALE, 0, Math.PI * 2);
        ctx.fill();

        // 分割線の描画（有声音ならR_BIGまで、無声音ならR_SMALLまで）
        if (config.lines > 0) {
            const lineLen = (config.type === 'big' || config.type === 'double') ? R_BIG : R_SMALL;
            ctx.beginPath();
            for (let i = 0; i < config.lines; i++) {
                const angle = (Math.PI * 2 / config.lines) * i - Math.PI / 2 + config.offset;
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * lineLen, y + Math.sin(angle) * lineLen);
            }
            ctx.stroke();
        }
    }

    function render() {
        const text = input.value.toLowerCase().replace(/[^iuotkspdgzbl,\.]/g, '');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let curX = 60;
        let curY = 150;
        
        canvas.width = Math.max(1000, text.length * 70 + 100);
        canvas.height = 400;

        for (let i = 0; i < text.length; i++) {
            let char = text[i];
            
            if (CHAR_MAP[char]) {
                drawSymbol(curX, curY, char);
                const currentR = CHAR_MAP[char].r;
                
                let next = text[i+1];
                if (!next) break;

                if ("iuo".includes(next)) {
                    let angle = 0;
                    if (next === 'i') angle = -Math.PI / 6;
                    if (next === 'u') angle = Math.PI / 6;

                    let afterVowel = text[i+2];
                    if (afterVowel) {
                        if (CHAR_MAP[afterVowel]) {
                            let dist = currentR + CHAR_MAP[afterVowel].r;
                            curX += Math.cos(angle) * dist;
                            curY += Math.sin(angle) * dist;
                            i++; 
                        } else if (afterVowel === ',') {
                            let dist = currentR + R_DOT;
                            curX += Math.cos(angle) * dist;
                            curY += Math.sin(angle) * dist;
                            ctx.beginPath();
                            ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                            ctx.stroke();
                            curX += 45 * SCALE;
                            curY = 150;
                            i += 2;
                        } else {
                            // ピリオドなどが来た場合
                            curX += 45 * SCALE;
                            curY = 150;
                            i++;
                        }
                    } else {
                        break; 
                    }
                } else if (CHAR_MAP[next]) {
                    let targetX = curX + BASE_LINE_DIST;
                    let targetY = curY;
                    ctx.beginPath();
                    ctx.moveTo(curX, curY);
                    ctx.lineTo(targetX, targetY);
                    ctx.stroke();
                    curX = targetX;
                    curY = targetY;
                } else if (next === ',') {
                    let targetX = curX + 25 * SCALE;
                    ctx.beginPath();
                    ctx.moveTo(curX, curY);
                    ctx.lineTo(targetX, curY);
                    ctx.stroke();
                    curX = targetX;
                }
            } else if (char === ',') {
                ctx.beginPath();
                ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                ctx.stroke();
                curX += 45 * SCALE;
                curY = 150;
            } else if (char === '.') {
                const h = R_SMALL;
                ctx.beginPath();
                ctx.moveTo(curX + 5, curY - h); ctx.lineTo(curX + 5, curY + h);
                ctx.moveTo(curX + 15, curY - h); ctx.lineTo(curX + 15, curY + h);
                ctx.stroke();
                curX += 50 * SCALE;
                curY = 150;
            }
        }
    }

    input.addEventListener('input', render);
    render();
</script>

</body>
</html>
