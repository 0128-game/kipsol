<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>キプソル語メモ帳 v8.1</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { background: white; padding: 25px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 95%; max-width: 1000px; }
        h2 { color: #333; margin-top: 0; border-bottom: 2px solid #007bff; display: inline-block; padding-bottom: 5px; }
        textarea { width: 100%; height: 180px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 18px; margin-bottom: 15px; resize: vertical; outline: none; box-sizing: border-box; line-height: 1.5; }
        textarea:focus { border-color: #007bff; }
        .button-group { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 6px; transition: background 0.2s; font-weight: bold; }
        .btn-save { background-color: #28a745; color: white; }
        .btn-save:hover { background-color: #218838; }
        .btn-clear { background-color: #6c757d; color: white; }
        .btn-clear:hover { background-color: #5a6268; }
        .toggle-container { display: flex; align-items: center; gap: 8px; font-size: 14px; color: #444; cursor: pointer; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        #canvas-container { width: 100%; overflow-x: auto; background: #fff; border: 1px solid #ccc; border-radius: 8px; min-height: 200px; background-image: 
            linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee), 
            linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee);
            background-size: 20px 20px; background-position: 0 0, 10px 10px; }
        canvas { display: block; margin: 0 auto; }
        .info { font-size: 0.85rem; color: #555; line-height: 1.6; background: #e9ecef; padding: 15px; border-radius: 8px; margin-top: 20px; }
    </style>
</head>
<body>

<div class="container">
    <h2>キプソル語メモ帳</h2>
    <textarea id="input" placeholder="lol,tusnu,suzdubol,kikos,gu,kipsol,su,kinzok,.&#10;lol,lusku,kiznok,.&#10;lol,zidbulu,kikos,.&#10;lol,zignubu,kikis,lizok,.&#10;lol,tusno,sudubol,su,kipsol,.&#10;(動画内日誌より)"></textarea>
    
    <div class="button-group">
        <button class="btn-save" id="save-btn">画像として保存 (PNG)</button>
        <label class="toggle-container">
            <input type="checkbox" id="transparent-check"> 背景を透過させる
        </label>
        <button class="btn-clear" id="clear-btn">クリア</button>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="info">
        <strong>【キプソル語 (Kipsol) 記法ルールまとめ】</strong><br>
        ・<strong>子音+母音+子音/語末</strong>：円同士が直接接触（i:右上, u:右下, o:右）。<br>
        ・<strong>子音+子音</strong>：中心を直線で接続。<br>
        ・<strong>有声音(d,g,z,b)</strong>：大円。 <strong>無声音(t,k,s,p)</strong>：小円。<br>
        ・<strong>l, n</strong>：二重円（nは3等分線あり）。
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('input');
    const saveBtn = document.getElementById('save-btn');
    const clearBtn = document.getElementById('clear-btn');
    const transparentCheck = document.getElementById('transparent-check');

    const SCALE = 1.5;
    const R_BIG = 18 * SCALE;
    const R_SMALL = 10 * SCALE;
    const R_DOT = 3 * SCALE;
    const BASE_LINE_DIST = 45 * SCALE;
    const LINE_HEIGHT = 120 * SCALE;

    const CHAR_MAP = {
        'z': { r: R_BIG,   lines: 0, type: 'big'   , offset: 0 },
        's': { r: R_SMALL, lines: 0, type: 'small' , offset: 0 },
        'd': { r: R_BIG,   lines: 3, type: 'big'   , offset: Math.PI / 6 },
        't': { r: R_SMALL, lines: 3, type: 'small' , offset: Math.PI / 6 },
        'g': { r: R_BIG,   lines: 4, type: 'big'   , offset: Math.PI / 4 },
        'k': { r: R_SMALL, lines: 4, type: 'small' , offset: Math.PI / 4 },
        'b': { r: R_BIG,   lines: 6, type: 'big'   , offset: 0 },
        'p': { r: R_SMALL, lines: 6, type: 'small' , offset: 0 },
        'l': { r: R_BIG,   lines: 0, type: 'double', offset: 0 },
        'n': { r: R_BIG,   lines: 3, type: 'double', offset: Math.PI / 6 },
    };

    function drawSymbol(x, y, charCode) {
        const config = CHAR_MAP[charCode];
        if (!config) return;
        ctx.beginPath();
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#333';
        
        if (config.type === 'big' || config.type === 'double') {
            ctx.moveTo(x + R_BIG, y);
            ctx.arc(x, y, R_BIG, 0, Math.PI * 2);
        }
        if (config.type === 'small' || config.type === 'double') {
            ctx.moveTo(x + R_SMALL, y);
            ctx.arc(x, y, R_SMALL, 0, Math.PI * 2);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = '#333';
        ctx.arc(x, y, 2 * SCALE, 0, Math.PI * 2);
        ctx.fill();

        if (config.lines > 0) {
            const lineLen = (config.type === 'big' || config.type === 'double') ? R_BIG : R_SMALL;
            ctx.beginPath();
            for (let i = 0; i < config.lines; i++) {
                const angle = (Math.PI * 2 / config.lines) * i - Math.PI / 2 + config.offset;
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * lineLen, y + Math.sin(angle) * lineLen);
            }
            ctx.stroke();
        }
    }

    function render() {
        const fullText = input.value.toLowerCase();
        const lines = fullText.split('\n');
        
        let maxChars = 0;
        lines.forEach(l => {
            const filtered = l.replace(/[^iuotkspdgzbln,\.]/g, '');
            if(filtered.length > maxChars) maxChars = filtered.length;
        });

        canvas.width = Math.max(800, maxChars * 85 + 150);
        canvas.height = Math.max(300, lines.length * LINE_HEIGHT + 100);
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 保存時や表示用に背景を白く塗る（透過チェックがない場合）
        if (!transparentCheck.checked) {
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        lines.forEach((lineText, lineIndex) => {
            const text = lineText.replace(/[^iuotkspdgzbln,\.]/g, '');
            let curX = 60;
            let baseRowY = 80 * SCALE + (lineIndex * LINE_HEIGHT);
            let curY = baseRowY;

            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                if (CHAR_MAP[char]) {
                    drawSymbol(curX, curY, char);
                    const currentR = CHAR_MAP[char].r;
                    let next = text[i+1];
                    if (!next) break;

                    if ("iuo".includes(next)) {
                        let angle = 0;
                        if (next === 'i') angle = -Math.PI / 6;
                        if (next === 'u') angle = Math.PI / 6;
                        let afterVowel = text[i+2];
                        if (afterVowel) {
                            if (CHAR_MAP[afterVowel]) {
                                let dist = currentR + CHAR_MAP[afterVowel].r;
                                curX += Math.cos(angle) * dist;
                                curY += Math.sin(angle) * dist;
                                i++; 
                            } else if (afterVowel === ',') {
                                let dist = currentR + R_DOT;
                                curX += Math.cos(angle) * dist;
                                curY += Math.sin(angle) * dist;
                                ctx.beginPath();
                                ctx.strokeStyle = '#333';
                                ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                                ctx.stroke();
                                curX += 50 * SCALE;
                                curY = baseRowY;
                                i += 2;
                            } else {
                                curX += 50 * SCALE;
                                curY = baseRowY;
                                i++;
                            }
                        } else break;
                    } else if (CHAR_MAP[next]) {
                        let targetX = curX + BASE_LINE_DIST;
                        ctx.beginPath();
                        ctx.strokeStyle = '#333';
                        ctx.moveTo(curX, curY);
                        ctx.lineTo(targetX, curY);
                        ctx.stroke();
                        curX = targetX;
                    } else if (next === ',') {
                        let targetX = curX + 25 * SCALE;
                        ctx.beginPath();
                        ctx.strokeStyle = '#333';
                        ctx.moveTo(curX, curY);
                        ctx.lineTo(targetX, curY);
                        ctx.stroke();
                        curX = targetX;
                    }
                } else if (char === ',') {
                    ctx.beginPath();
                    ctx.strokeStyle = '#333';
                    ctx.arc(curX, curY, R_DOT, 0, Math.PI * 2);
                    ctx.stroke();
                    curX += 50 * SCALE;
                    curY = baseRowY;
                } else if (char === '.') {
                    const h = R_SMALL;
                    ctx.beginPath();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2.5;
                    ctx.moveTo(curX + 5, curY - h); ctx.lineTo(curX + 5, curY + h);
                    ctx.moveTo(curX + 15, curY - h); ctx.lineTo(curX + 15, curY + h);
                    ctx.stroke();
                    curX += 60 * SCALE;
                    curY = baseRowY;
                }
            }
        });
    }

    saveBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'kipsol_note.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    });

    clearBtn.addEventListener('click', () => {
        if(confirm('入力をすべて消去しますか？')) {
            input.value = '';
            render();
        }
    });

    transparentCheck.addEventListener('change', render);
    input.addEventListener('input', render);
    render();
</script>

</body>
</html>
